#include <fstream>

void Write_LFSR()
{
  std::fstream fd;

  fd.open("RS_LFSR.vhd", std::fstream::out);

  fd << "library IEEE;\n"
        "use IEEE.std_logic_1164.all;\n"
        "use IEEE.numeric_std.all;\n"
        "use work.ReedSolomon.all;\n"
        "\n"
        "entity LFSR is\n"
        "  port (\n"
        "    clock          : in  std_logic;\n"
        "    reset          : in  std_logic;\n"
        "    message_start  : in  std_logic;\n"
        "    message        : in  field_element;\n"
        "    codeword       : out field_element;\n"
        "    parity_ready   : out std_logic;\n"
        "    parity_shifted : out std_logic);\n"
        "end LFSR;\n"
        "\n"
        "architecture LFSR of LFSR is\n"
        "  component field_element_multiplier\n"
        "    port (\n"
        "      u : in  field_element;\n"
        "      v : in  field_element;\n"
        "      w : out field_element);\n"
        "  end component;\n"
        "\n"
        "  signal enable_calculation : std_logic;\n"
        "\n"
        "  signal feed_through : field_element;\n"
        "\n"
        "  signal intermediary_poly : T2less1_array;\n"
        "  signal multiplicand_poly : T2less1_array;\n"
        "\n"
        "  signal parity_counter : unsigned(T - 1 downto 0);\n"
        "  signal message_counter : unsigned(T downto 0);\n"
        "\n"
        "begin\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Multiplication of the received symbol by the highest order\n"
        "  -- element from the partial polynomial\n"
        "  -----------------------------------------------------------------------------\n"
        "  feed_through <= (others => '0') when reset = '1' or message_start = '1' else\n"
        "                  message xor intermediary_poly(T2 - 1);\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Multiplication of the feed_through signal by each of the generator\n"
        "  -- polynomial's coefficients.\n"
        "  -----------------------------------------------------------------------------\n"
        "  alphas : for I in 0 to T2 - 1 generate\n"
        "    alphaX : field_element_multiplier port map (feed_through, gen_poly(I), multiplicand_poly(I));\n"
        "  end generate alphas;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Enable signal\n"
        "  -----------------------------------------------------------------------------\n"
        "  process(clock)\n"
        "  begin\n"
        "    if clock'event and clock = '1' then\n"
        "      if reset = '1' or parity_counter = 0 then\n"
        "        enable_calculation <= '0';\n"
        "      elsif message_start = '1' then\n"
        "        enable_calculation <= '1';\n"
        "      end if;\n"
        "    end if;\n"
        "  end process;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Message counter\n"
        "  -----------------------------------------------------------------------------\n"
        "  process(clock)\n"
        "  begin\n"
        "    if clock'event and clock = '1' then\n"
        "      if reset = '1' or message_start = '1' then\n"
        "        message_counter <= (others => '0');\n"
        "      elsif enable_calculation = '1' and message_counter < K_LENGTH + 2 then\n"
        "        message_counter <= message_counter + 1;\n"
        "      end if;\n"
        "    end if;\n"
        "  end process;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Parity counter\n"
        "  -----------------------------------------------------------------------------\n"
        "  process(clock)\n"
        "  begin\n"
        "    if clock'event and clock = '1' then\n"
        "      if reset = '1' or message_start = '1' then\n"
        "        parity_counter <= to_unsigned(T2 - 1, T);\n"
        "      elsif enable_calculation = '1' and message_counter = K_LENGTH + 2 then\n"
        "        if parity_counter > 0 then\n"
        "          parity_counter <= parity_counter - 1;\n"
        "        else\n"
        "          parity_counter <= (others => '0');\n"
        "        end if;\n"
        "      end if;\n"
        "    end if;\n"
        "  end process;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Parity calculation\n"
        "  -----------------------------------------------------------------------------\n"
        "  process(clock)\n"
        "  begin\n"
        "    if clock'event and clock = '1' then\n"
        "      if reset = '1' or message_start = '1' then\n"
        "        intermediary_poly <= (others => (others => '0'));\n"
        "      elsif message_counter < K_LENGTH + 1 then\n"
        "        intermediary_poly(0)  <= multiplicand_poly(0);\n"
        "        for i in 1 to T2 - 1 loop\n"
        "          intermediary_poly(i)  <= multiplicand_poly(i) xor intermediary_poly(i - 1);\n"
        "        end loop;\n"
        "      elsif enable_calculation = '1' and message_counter = K_LENGTH + 2 then\n"
        "        intermediary_poly <= all_zeros & intermediary_poly(0 to T2 - 2);\n"
        "      end if;\n"
        "    end if;\n"
        "  end process;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Set parity_ready signal\n"
        "  -----------------------------------------------------------------------------\n"
        "  process(message_counter)\n"
        "  begin\n"
        "    if message_counter /= K_LENGTH + 2 then\n"
        "      parity_ready <= '0';\n"
        "    else\n"
        "      parity_ready <= '1';\n"
        "    end if;\n"
        "  end process;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Set parity_shifted signal\n"
        "  -----------------------------------------------------------------------------\n"
        "  process(parity_counter)\n"
        "  begin\n"
        "    if parity_counter /= 0 then\n"
        "      parity_shifted <= '0';\n"
        "    else\n"
        "      parity_shifted <= '1';\n"
        "    end if;\n"
        "  end process;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Output parity symbols\n"
        "  -----------------------------------------------------------------------------\n"
        "  codeword <= intermediary_poly(T2 - 1);\n"
        "\n"
        "end architecture;\n";

  fd.close();
}
