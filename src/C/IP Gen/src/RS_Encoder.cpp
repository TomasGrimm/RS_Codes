#include <fstream>

void Write_Encoder()
{
  std::fstream fd;

  fd.open("RS_Encoder.vhd", std::fstream::out);

  fd << "library IEEE;\n"
        "use IEEE.std_logic_1164.all;\n"
        "use IEEE.numeric_std.all;\n"
        "use work.ReedSolomon.all;\n"
        "\n"
        "-- Reed-Solomon Encoder\n"
        "\n"
        "entity RS_coder is\n"
        "  port (\n"
        "    clock         : in  std_logic;      -- clock signal\n"
        "    reset         : in  std_logic;  -- signal used to clear all registers and the ready signal\n"
        "    message_start : in  std_logic;  -- indicates when a new message is ready to be encoded\n"
        "    message       : in  field_element;  -- message to be encoded\n"
        "    done          : out std_logic;      -- signals when the processing is done\n"
        "    codeword      : out field_element);  -- codeword containing the message and the calculated parity bits\n"
        "end entity;\n"
        "\n"
        "architecture RS_coder of RS_coder is\n"
        "  component field_element_multiplier\n"
        "    port (\n"
        "      u : in  field_element;\n"
        "      v : in  field_element;\n"
        "      w : out field_element);\n"
        "  end component;\n"
        "\n"
        "  signal enable_calculation : std_logic;\n"
        "  signal parity_ready       : std_logic;\n"
        "\n"
        "  signal delay        : field_element;\n"
        "  signal feed_through : field_element;\n"
        "\n"
        "  signal intermediary_poly : T2less1_array;\n"
        "  signal multiplicand_poly : T2less1_array;\n"
        "\n"
        "  signal parity_counter  : unsigned(SYMBOL_LENGTH/2 downto 0);\n"
        "  signal message_counter : unsigned(SYMBOL_LENGTH downto 0);\n"
        "  \n"
        "begin\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Delay the message symbol for one cycle to avoid a gap between message\n"
        "  -- and parity\n"
        "  -----------------------------------------------------------------------------\n"
        "  process(clock)\n"
        "  begin\n"
        "    if clock'event and clock = '1' then\n"
        "      if reset = '1' then\n"
        "        delay <= (others => '0');\n"
        "      else\n"
        "        delay <= message;\n"
        "      end if;\n"
        "    end if;\n"
        "  end process;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Multiplication of the received symbol by the highest order \n"
        "  -- element from the partial polynomial\n"
        "  -----------------------------------------------------------------------------\n"
        "  feed_through <= (others => '0') when reset = '1' or message_start = '1' else\n"
        "                  message xor intermediary_poly(T2 - 1) when enable_calculation = '1' else\n"
        "                  all_zeros;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Multiplication of the feed_through signal by each of the generator\n"
        "  -- polynomial's coefficients.\n"
        "  -----------------------------------------------------------------------------\n"
        "  alphas : for I in 0 to T2 - 1 generate\n"
        "    alphaX : field_element_multiplier port map (feed_through, gen_poly(I), multiplicand_poly(I));\n"
        "  end generate alphas;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Enable signal\n"
        "  -----------------------------------------------------------------------------\n"
        "  process(clock)\n"
        "  begin\n"
        "    if clock'event and clock = '1' then\n"
        "      if reset = '1' or parity_counter = 0 then\n"
        "        enable_calculation <= '0';\n"
        "      elsif message_start = '1' then\n"
        "        enable_calculation <= '1';\n"
        "      end if;\n"
        "    end if;\n"
        "  end process;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Message counter\n"
        "  -----------------------------------------------------------------------------\n"
        "  process(clock)\n"
        "  begin\n"
        "    if clock'event and clock = '1' then\n"
        "      if reset = '1' or message_start = '1' or parity_counter = 0 then\n"
        "        message_counter <= (others => '0');\n"
        "      elsif enable_calculation = '1' and message_counter < K_LENGTH + 2 then\n"
        "        message_counter <= message_counter + 1;\n"
        "      end if;\n"
        "    end if;\n"
        "  end process;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Parity counter\n"
        "  -----------------------------------------------------------------------------\n"
        "  process(clock)\n"
        "  begin\n"
        "    if clock'event and clock = '1' then\n"
        "      if reset = '1' or message_start = '1' or parity_counter = 0 then\n"
        "        parity_counter <= to_unsigned(T2 - 1, SYMBOL_LENGTH/2 + 1);\n"
        "      elsif enable_calculation = '1' and message_counter = K_LENGTH + 2 then\n"
        "        if parity_counter > 0 then\n"
        "          parity_counter <= parity_counter - 1;\n"
        "        else\n"
        "          parity_counter <= (others => '0');\n"
        "        end if;\n"
        "      end if;\n"
        "    end if;\n"
        "  end process;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Parity calculation\n"
        "  -----------------------------------------------------------------------------\n"
        "  process(clock)\n"
        "  begin\n"
        "    if clock'event and clock = '1' then\n"
        "      if reset = '1' or message_start = '1' then\n"
        "        intermediary_poly <= (others => (others => '0'));\n"
        "      elsif message_counter < K_LENGTH + 1 then\n"
        "        intermediary_poly(0) <= multiplicand_poly(0);\n"
        "        for i in 1 to T2 - 1 loop\n"
        "          intermediary_poly(i) <= multiplicand_poly(i) xor intermediary_poly(i - 1);\n"
        "        end loop;\n"
        "      elsif enable_calculation = '1' and message_counter = K_LENGTH + 2 then\n"
        "        intermediary_poly <= all_zeros & intermediary_poly(0 to T2 - 2);\n"
        "      end if;\n"
        "    end if;\n"
        "  end process;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Set parity_ready signal\n"
        "  -----------------------------------------------------------------------------\n"
        "  process(message_counter)\n"
        "  begin\n"
        "    if message_counter /= K_LENGTH + 2 then\n"
        "      parity_ready <= '0';\n"
        "    else\n"
        "      parity_ready <= '1';\n"
        "    end if;\n"
        "  end process;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Set parity_shifted signal\n"
        "  -----------------------------------------------------------------------------\n"
        "  process(clock)\n"
        "  begin\n"
        "    if clock'event and clock = '1' then\n"
        "      if parity_counter /= 0 then\n"
        "        done <= '0';\n"
        "      else\n"
        "        done <= '1';\n"
        "      end if;\n"
        "    end if;\n"
        "  end process;\n"
        "\n"
        "  -----------------------------------------------------------------------------\n"
        "  -- Output parity symbols\n"
        "  -----------------------------------------------------------------------------\n"
        "  codeword <= delay when parity_ready = '0' else\n"
        "              intermediary_poly(T2 - 1);\n"
        "  \n"
    "end architecture;\n";

  fd.close();
}

